<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Celery 如何手动路由任务 | iT2afL0rd's Blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">iT2afL0rd's Blog</a><span class="subtitle">Energy and Persistence conquers</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>Celery 如何手动路由任务</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2013-12-20</div><div class="post-categories"><a class="post-category-link" href="/categories/Python/">Python</a></div><div class="post-tags"><a class="post-tag-link" href="/tags/Celery/">Celery</a></div></div></div><article><div class="container post"><h2 id="什么是Celery"><a href="#什么是Celery" class="headerlink" title="什么是Celery"></a>什么是Celery</h2><p>Celery是一款开源的分布式异步任务队列，主要用于完成实时任务，也可以执行计划任务。<br>它的执行单元叫task，可以在一个或多个任务节点（Worker）上执行。这些Task支持使用multiprocessing，eventlet以及gevent运行。<br>详细的介绍请参阅Celery官网：<a href="http://www.celeryproject.org/ “Celery”" target="_blank" rel="external">http://www.celeryproject.org/</a>。</p>
<h3 id="Celery怎么用"><a href="#Celery怎么用" class="headerlink" title="Celery怎么用"></a>Celery怎么用</h3><p>Celery在生产环境中一般都是搭配消息队列使用。官方推荐的消息队列为RabbitMQ，同时也支持使用Redis、SQLAlchemy、Amazon SQS、MongoDB以及IronMQ等。<br>celery可以将任务分发到消息队列（Broker）中，Broker再将任务发送到各个Worker，Worker可以根据各个服务器的负载部署。<br>关于RabbitMQ的使用，可以看这里：<a href="http://docs.celeryproject.org/en/latest/getting-started/brokers/rabbitmq.html#broker-rabbitmq “Using RabbitMQ”" target="_blank" rel="external">http://docs.celeryproject.org/en/latest/getting-started/brokers/rabbitmq.html#broker-rabbitmq</a>。</p>
<h3 id="RabbitMQ基础之Exchange和Queue"><a href="#RabbitMQ基础之Exchange和Queue" class="headerlink" title="RabbitMQ基础之Exchange和Queue"></a>RabbitMQ基础之Exchange和Queue</h3><p>了解下面的内容需要对RabbitMQ中的Exchange和Queue有基础的了解，这里稍微解释一下。<br>RabbitMQ中的Exchange和Queue简单来说是一种包含的关系，一个Exchange下可以有多个Queue。<br>Celery的Worker一般都是连到Exchange下，Topic类型的Exchange（也有其他类型的Exchange，这里不做解释）收到消息之后可以根据消息的路由值（routing key）不同将消息转发的不同的Queue上。<br>我们这里说的手动路由任务就是利用了RabbitMQ的Exchange，Queue以及Routing Key。</p>
<h2 id="celery路由"><a href="#celery路由" class="headerlink" title="celery路由"></a>celery路由</h2><p>每一个Celery的Worker都要连到一个RabbitMQ的Exchange，一般来说Celery的配置文件里都有这样一句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BROKER_URL = <span class="string">'amqp://username:passwd@10.40.146.104:5672/rabbitmq_vhost'</span></span><br></pre></td></tr></table></figure></p>
<p>这其实是指定Celery连的RabbitMQ的Broker，如果不指定Exchange，Queue和Routing Key，RabbitMQ会默认生成。如果要指定，可以这么写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CELERY_DEFAULT_EXCHANGE = <span class="string">'exchange_name'</span></span><br><span class="line">CELERY_DEFAULT_EXCHANGE_TYPE = <span class="string">'topic'</span></span><br><span class="line">CELERY_DEFAULT_QUEUE = <span class="string">'queue_name'</span></span><br><span class="line">CELERY_DEFAULT_ROUTING_KEY = <span class="string">'routing_key_name'</span></span><br></pre></td></tr></table></figure></p>
<p>这样配置了之后，Celery就会用这些配置来路由任务。这其实就是自动路由了。</p>
<h3 id="Celery手动路由"><a href="#Celery手动路由" class="headerlink" title="Celery手动路由"></a>Celery手动路由</h3><p>可以看到，Celery的自动路由还是很简单的，但是，在项目中，我们经常会有这样的需求：当有多种Task的时候，我们希望把一种Task给一Worker，而把另外一种Task给另外一个Worker。在这样的需求下，上面的自动路由明显就不能胜任了。<br>而且目前Celery也不支持Task的优先级设置，所以很明显当Task有优先级时，自动路由简单地排队功能就不适用了。</p>
<p>假设你在两个服务器上分别有Worker X和Worker Y，这两个处理普通的Task；在另一个服务器上有Worker Z，用来处理优先级更高的Task。你可以用这样的配置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kombu <span class="keyword">import</span> Queue</span><br><span class="line">CELERY_DEFAULT_EXCHANGE = ‘exchange_name’</span><br><span class="line">CELERY_DEFAULT_EXCHANGE_TYPE = ‘topic’</span><br><span class="line">CELERY_DEFAULT_QUEUE = ‘default’</span><br><span class="line">CELERY_DEFAULT_ROUTING_KEY = ‘task.default’</span><br><span class="line">CELERY_QUEUES = (</span><br><span class="line">		Queue(‘default’, routing_key=‘task.<span class="comment">#’),</span></span><br><span class="line">		Queue(‘high_priority’, routing_key=‘high_priority.<span class="comment">#’),</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">CELERY_ROUTES = &#123;</span><br><span class="line">		‘high_priority_task’: &#123;</span><br><span class="line">		‘queue’: ‘high_priority’,</span><br><span class="line">		‘routing_key’: ‘high_priority.<span class="comment">#’,</span></span><br><span class="line">		&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里配置了2个Queue，default绑定的routing_key是task.#（#是任意匹配），high_priority绑定的routing_key是high_priority.#。默认情况下，Task会发到default Queue上，routing_key是task.#；当你发送Task时指定了Queue和routing_key之后，RabbitMQ会根据CELERY_ROUTES里的配置将Task发送到配置好的Queue上。<br>这里要注意的是在启Worker的时候也要指定Queue。所以X和Y启动的时候要这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery worker -Q default</span><br></pre></td></tr></table></figure></p>
<p>Z启动时要这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery worker -Q high_priority</span><br></pre></td></tr></table></figure></p>
<p>都配置好之后，如果要将Task发送给X和Y（这里省略了一些参数，意思是使用默认的）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send_task(‘task_name’, args=[args_list])</span><br></pre></td></tr></table></figure></p>
<p>发送Task给Z：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send_task(‘task_name’, args=[args_list], queue=‘high_priority’, routing_key=‘high_priority.name’)</span><br></pre></td></tr></table></figure></p>
<h3 id="“自动化”的手动路由"><a href="#“自动化”的手动路由" class="headerlink" title="“自动化”的手动路由"></a>“自动化”的手动路由</h3><p>上面的例子是只有2个Queue的情况，在项目中有时候会因为性能或者其他一些方面的考虑而需求让每个Worker处理特定的Task（其实Celery是不希望用户这么做的）。当你有100+台服务器时，你会发现上面的配置会写的很长很长；而且当你有新的服务器时，又要去改配置，非常的不方便。<br>这里的思路还是比较简单的，一般来说这些服务器都是在同一个网段的，可以默认以每一台机器的IP作为Queue的名字。那么每个Worker的配置可以这么写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> kombu <span class="keyword">import</span> Queue</span><br><span class="line">LOCAL_IP = socket.gethostbyname(socket.gethostname()).replace(‘.’, ‘_’)</span><br><span class="line">CELERY_QUEUES = (</span><br><span class="line">		Queue(‘%s’ % LOCAL_IP, routing_key=‘routing_key_%s’ % LOCAL_IP),</span><br><span class="line">)</span><br><span class="line">CELERY_ROUTES = &#123;</span><br><span class="line">		‘route_%s’ % LOCAL_IP: &#123;</span><br><span class="line">		‘queue’: ‘%s’ % LOCAL_IP,</span><br><span class="line">		‘routing_key’: ‘routing_key_%s’ % LOCAL_IP,</span><br><span class="line">		&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我用下划线代替了IP地址中的点号。这样写了之后每一个Worker启动时的Queue应该是本机的IP地址，假设我在192.168.10.4上：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery worker -Q <span class="number">192</span>_168_10_4</span><br></pre></td></tr></table></figure></p>
<p>发送Task模块的配置有一些不同，需要遍历当前网段的机器IP：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kombu <span class="keyword">import</span> Queue</span><br><span class="line">SERVERS = []</span><br><span class="line"><span class="keyword">for</span> address <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">256</span>):</span><br><span class="line">		SERVERS.append(‘<span class="number">192</span>_168_10_%d’ % address)</span><br><span class="line">CELERY_QUEUES = []</span><br><span class="line">CELERY_ROUTES = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> ser <span class="keyword">in</span> SERVERS:</span><br><span class="line">		CELERY_QUEUES.append(Queue(‘%s’ % ser, routing_key=‘routing_key_%s’ % ser))</span><br><span class="line">	CELERY_ROUTES[‘route_%s’ % ser] = &#123;</span><br><span class="line">		‘queue’: ‘%s’ % ser,</span><br><span class="line">		‘routing_key’: ‘routing_key_%s’ % ser,</span><br><span class="line">	&#125;</span><br><span class="line">CELERY_QUEUES = tuple(CELERY_QUEUES)</span><br></pre></td></tr></table></figure></p>
<p>配置好了之后要发送Task给某个服务器时，Queue就是IP，routing_key就是”routing_key_IP”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然这样的功能可以实现，但是作为一款分布式的任务队列，非特殊情况下最好不要这样使用。毕竟这样其实是失去了分布式的意义。</p>
</div><!-- comment system--><div data-thread-key="2013/12/20/python/celery-manual-routing/" data-title="Celery 如何手动路由任务" data-url="http://lsq.me/2013/12/20/python/celery-manual-routing/" class="container ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div class="container"><hr><div data-thread-key="2013/12/20/python/celery-manual-routing/" data-title="Celery 如何手动路由任务" data-url="http://lsq.me/2013/12/20/python/celery-manual-routing/" data-author-key="1" class="ds-thread"></div></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:qsunme@126.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a href="https://github.com/https://github.com/iT2afL0rd" target="_blank"><i class="fa fa-github"></i></a><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2016 <a href="/" rel="nofollow">iT2afL0rd's Blog</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});</script></body></html>